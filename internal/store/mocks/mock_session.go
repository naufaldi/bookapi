// Code generated by MockGen. DO NOT EDIT.
// Source: internal/usecase/session.go

// Package mocks is a generated GoMock package.
package mocks

import (
	entity "bookapi/internal/entity"
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
)

// MockSessionRepository is a mock of SessionRepository interface.
type MockSessionRepository struct {
	ctrl     *gomock.Controller
	recorder *MockSessionRepositoryMockRecorder
}

// MockSessionRepositoryMockRecorder is the mock recorder for MockSessionRepository.
type MockSessionRepositoryMockRecorder struct {
	mock *MockSessionRepository
}

// NewMockSessionRepository creates a new mock instance.
func NewMockSessionRepository(ctrl *gomock.Controller) *MockSessionRepository {
	mock := &MockSessionRepository{ctrl: ctrl}
	mock.recorder = &MockSessionRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSessionRepository) EXPECT() *MockSessionRepositoryMockRecorder {
	return m.recorder
}

// CleanupExpired mocks base method.
func (m *MockSessionRepository) CleanupExpired(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CleanupExpired", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// CleanupExpired indicates an expected call of CleanupExpired.
func (mr *MockSessionRepositoryMockRecorder) CleanupExpired(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CleanupExpired", reflect.TypeOf((*MockSessionRepository)(nil).CleanupExpired), ctx)
}

// Create mocks base method.
func (m *MockSessionRepository) Create(ctx context.Context, session *entity.Session) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx, session)
	ret0, _ := ret[0].(error)
	return ret0
}

// Create indicates an expected call of Create.
func (mr *MockSessionRepositoryMockRecorder) Create(ctx, session interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockSessionRepository)(nil).Create), ctx, session)
}

// Delete mocks base method.
func (m *MockSessionRepository) Delete(ctx context.Context, sessionID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, sessionID)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockSessionRepositoryMockRecorder) Delete(ctx, sessionID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockSessionRepository)(nil).Delete), ctx, sessionID)
}

// DeleteByTokenHash mocks base method.
func (m *MockSessionRepository) DeleteByTokenHash(ctx context.Context, tokenHash string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteByTokenHash", ctx, tokenHash)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteByTokenHash indicates an expected call of DeleteByTokenHash.
func (mr *MockSessionRepositoryMockRecorder) DeleteByTokenHash(ctx, tokenHash interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteByTokenHash", reflect.TypeOf((*MockSessionRepository)(nil).DeleteByTokenHash), ctx, tokenHash)
}

// GetByTokenHash mocks base method.
func (m *MockSessionRepository) GetByTokenHash(ctx context.Context, tokenHash string) (entity.Session, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByTokenHash", ctx, tokenHash)
	ret0, _ := ret[0].(entity.Session)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByTokenHash indicates an expected call of GetByTokenHash.
func (mr *MockSessionRepositoryMockRecorder) GetByTokenHash(ctx, tokenHash interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByTokenHash", reflect.TypeOf((*MockSessionRepository)(nil).GetByTokenHash), ctx, tokenHash)
}

// ListByUserID mocks base method.
func (m *MockSessionRepository) ListByUserID(ctx context.Context, userID string) ([]entity.Session, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListByUserID", ctx, userID)
	ret0, _ := ret[0].([]entity.Session)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListByUserID indicates an expected call of ListByUserID.
func (mr *MockSessionRepositoryMockRecorder) ListByUserID(ctx, userID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListByUserID", reflect.TypeOf((*MockSessionRepository)(nil).ListByUserID), ctx, userID)
}

// UpdateLastUsed mocks base method.
func (m *MockSessionRepository) UpdateLastUsed(ctx context.Context, sessionID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateLastUsed", ctx, sessionID)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateLastUsed indicates an expected call of UpdateLastUsed.
func (mr *MockSessionRepositoryMockRecorder) UpdateLastUsed(ctx, sessionID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateLastUsed", reflect.TypeOf((*MockSessionRepository)(nil).UpdateLastUsed), ctx, sessionID)
}

// MockBlacklistRepository is a mock of BlacklistRepository interface.
type MockBlacklistRepository struct {
	ctrl     *gomock.Controller
	recorder *MockBlacklistRepositoryMockRecorder
}

// MockBlacklistRepositoryMockRecorder is the mock recorder for MockBlacklistRepository.
type MockBlacklistRepositoryMockRecorder struct {
	mock *MockBlacklistRepository
}

// NewMockBlacklistRepository creates a new mock instance.
func NewMockBlacklistRepository(ctrl *gomock.Controller) *MockBlacklistRepository {
	mock := &MockBlacklistRepository{ctrl: ctrl}
	mock.recorder = &MockBlacklistRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBlacklistRepository) EXPECT() *MockBlacklistRepositoryMockRecorder {
	return m.recorder
}

// AddToken mocks base method.
func (m *MockBlacklistRepository) AddToken(ctx context.Context, jti, userID string, expiresAt interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddToken", ctx, jti, userID, expiresAt)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddToken indicates an expected call of AddToken.
func (mr *MockBlacklistRepositoryMockRecorder) AddToken(ctx, jti, userID, expiresAt interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddToken", reflect.TypeOf((*MockBlacklistRepository)(nil).AddToken), ctx, jti, userID, expiresAt)
}

// CleanupExpired mocks base method.
func (m *MockBlacklistRepository) CleanupExpired(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CleanupExpired", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// CleanupExpired indicates an expected call of CleanupExpired.
func (mr *MockBlacklistRepositoryMockRecorder) CleanupExpired(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CleanupExpired", reflect.TypeOf((*MockBlacklistRepository)(nil).CleanupExpired), ctx)
}

// IsBlacklisted mocks base method.
func (m *MockBlacklistRepository) IsBlacklisted(ctx context.Context, jti string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsBlacklisted", ctx, jti)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsBlacklisted indicates an expected call of IsBlacklisted.
func (mr *MockBlacklistRepositoryMockRecorder) IsBlacklisted(ctx, jti interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsBlacklisted", reflect.TypeOf((*MockBlacklistRepository)(nil).IsBlacklisted), ctx, jti)
}
